huogh变换
1.hough线变换
    基本原理: 直角坐标系中的直线描述为 ro = x*cos(theta) + y*sin(theta),
当(x,y)确定时, 在ro和theta构成的坐标系中这个方程会对应一条线.这样直角坐标系中
的每个点都可以映射为ro-theta坐标系中的一条线, 在直角坐标系中位于一条直线上的
所有点映射到ro-theta空间的线会交于一点.huohg变换的原理就是:先将直角坐标系中的
所有非零点映射到ro-theta坐标系,遍历ro-theta线中的所有点,累加命中的次数;
再找出ro-theta的点中命中次数高于阈值的点,这些点对应直角坐标系中的直线就是要找的直线.

1.1 基本hough线变换
step1: 将直角坐标系中的所有非零点映射到ro-theta坐标系,遍历ro-theta线中的所有点,
        累加命中的次数到累加器中
step2: 遍历累加器,找到值大于阈值且大于其8邻域点的点, 即为目标点
step3: 将所有目标点按照命中次数由大到小排序
step4: 将目标点变换为直角坐标中的直线并输出, 输出直线个数达到最大限制时停止

1.2 概率hough线变换
step1: 收集直角坐标系中所有非零点
step2: 随机选取非零点映射到ro-theta坐标系,遍历ro-theta线中的所有点,
        累加命中的次数到累加器中
step3: 每次对一个直角坐标中的点(x, y)进行映射和累加之后,都要选取命中次数大于阈值的
        累加器中的点, 这个点代表这经过(x, y)的一条直线. 然后以(x, y)为中心,
        沿着直线的两个方向搜索非零点, 如果找到则记录; 当连续命中零点的次数
        大于阈值时此方向停止搜索, 最后一个找到的非零点即为线在该方向的端点.
        两个方向都搜索完毕后,如果线的长度大于阈值,则找到一条线段
step4: 将找到的线段中的非零点在累加器中的计数清除, 以免该线段被重复检出
step5: 输出找到的线段的两个端点


2.hough圆变换
    基本原理: 先用canny算法计算出边缘图像, 并计算x方向和y方向的梯度;
选取每个canny边缘中的非零点(x, y)并且其x方向的梯度和y方向的梯度不能同时为0,
以(x, y)为中心, 找到与(x, y)的梯度垂直的两个方向的所有点, 在累加器中记录命中次数;
这样如果(x, y)是一个圆上的点, 则必然命中其圆心的点. 当所有的canny边缘点遍历完成后,
找到累加器中的极值点, 要找的圆的圆心就在这些候选圆心点中;遍历每个候选圆心点(cx, cy),
计算所有canny边缘点与(cx ,cy)的距离, 然后计算与(cx, cy)距离相同的点的最大个数.
最大个数大于阈值的就认为是圆, 其距离就是半径

程序流程:
step1: 用canny算法计算边缘图像, 用sobel算法计算x方向和y方向的一阶梯度
step2: 遍历边缘图像中的每个非零点(x, y), 并忽略其x方向和y方向梯度都为0的点;
        计算梯度的方向, 以(x, y)为中心, 沿着与梯度垂直的两个方向搜索所有点, 
        将命中次数记录入累加器中, 并记录(x, y)
step3: 遍历累加器, 记录命中次数大于阈值且大于其8邻域的点, 这些点为候选圆心
step4: 将累加器中的点按照命中次数由高到低进行排序
step5: 遍历每个候选圆心点(cx, cy), 如果(cx, cy)与之前检测到的圆的圆心距离太小,
        则忽略; 计算(cx, cy)与step2中记录的所有(x, y)点的距离, 然后按照距离由大小
        进行排列; 计算与(cx, cy)距离的差小于指定精度的点的个数,这些点可以认为是
        位于一个圆上; 记录个数/半径比最大的点的个数和半径; 如果最终的个数大于
        阈值, 则记录圆心和半径, 输出结果
